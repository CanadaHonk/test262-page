<!DOCTYPE html>
<html>
<head>
  <title>test262.fyi</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="style.css">
  <meta name="description" content="daily runner of test262 for many engines">
</head>

<body>
  <div id="sidebar">
    <div id="sidebar-contents">
      <h1 onclick="navigate('')">test262.fyi</h1>
      <h2>daily* runner of <a href="https://github.com/tc39/test262">test262</a> for <i>many</i> engines</h2>

      <hr>

      <div id="engines">
      </div>

      <hr id="before-overall">

      <hr id="before-times">

      <footer>
        generated <span id="generated_ago"></span> <span id="generated_in"></span><br>
        test262 revision <a href="" id="test262_rev"></a><br>
        <br>
        <a href="https://github.com/CanadaHonk/test262.fyi">source</a>. work in progress, not 100% accurate. <i>* mostly</i>
      </footer>
    </div>
  </div>

  <div id="content">
    <div id="table-options">
    <div>
      <input type="checkbox" id="vertical_file_graphs">
      <label for="vertical_file_graphs">Vertical file graphs</label>
    </div>
    </div>

    <table>
      <thead></thead>
      <tbody></tbody>
    </table>
  </div>

  <script>
    const names = {
      v8: 'V8',
      sm: 'SpiderMonkey',
      jsc: 'JavaScriptCore',
      hermes: 'Hermes',
      chakra: 'ChakraCore',
      qjs: 'QuickJS',
      libjs: 'LibJS',
      graaljs: 'GraalJS',
      xs: 'XS',
      nashorn: 'Nashorn',
      rhino: 'Rhino',
      engine262: 'engine262',
      boa: 'Boa',
      babel: 'Babel',
      swc: 'SWC'
    };

    const moreInfo = {
      v8: 'Chromium\'s JS engine, also used by Node and Deno',
      sm: 'Gecko\'s JS engine',
      jsc: 'WebKit\'s JS engine',
      hermes: 'Made for and used by React Native',
      chakra: 'Former JS engine for Edge',
      libjs: 'JS engine from SerenityOS, also used in Ladybird browser',
      graaljs: 'Built on GraalVM',
      engine262: 'ECMA262 in JavaScript!',
      nashorn: 'Old Java JS engine by Oracle',
      rhino: 'Java JS engine by Mozilla',
      boa: 'Experimental embeddable JS engine in Rust',
      babel: 'Babel 7 + core-js 3 running on Node 0.10 (ES5)',
      swc: 'SWC + core-js 3 running on Node 0.10 (ES5)',
    };

    const shortNames = {
      v8: 'V8',
      sm: 'SM',
      jsc: 'JSC',
      hermes: 'Hermes',
      chakra: 'Chakra',
      qjs: 'QJS',
      libjs: 'LJS',
      graaljs: 'Graal',
      xs: 'XS',
      nashorn: 'Nashorn',
      rhino: 'Rhino',
      engine262: 'e262',
      boa: 'Boa',
      babel: 'Babel',
      swc: 'SWC',
    };

    const categories = {
      babel: 'transformers',
      swc: 'transformers'
    };

    const niceEngineOrder = [ 'v8', 'sm', 'jsc', 'graaljs', 'hermes', 'qjs', 'xs', 'libjs', 'chakra', 'rhino', 'nashorn', 'boa', 'engine262', 'babel', 'swc' ];

    const thead = document.querySelector('thead');
    const tbody = document.querySelector('tbody');

    let cwd = '', filterOutEngines = [], init = false;

    if (location.hash) {
      const [ hashCwd, hashFilter ] = decodeURI(location.hash.slice(1)).split('|');
      if (hashCwd) cwd = hashCwd.trim();
      if (hashFilter) {
        const includedEngines = hashFilter.trim().split(',');
        filterOutEngines = niceEngineOrder.filter(x => !includedEngines.includes(x));
      }

      document.body.className = filterOutEngines.map(x => `no-stat-` + x).join(' ');
    }

    const makeHash = path => `#${path ?? ''}${filterOutEngines.length > 0 ? ('|' + niceEngineOrder.filter(x => !filterOutEngines.includes(x)).join(',')) : ''}`;

    let ignoreNextState = false;
    const updateHash = (push = false) => {
      ignoreNextState = true;
      history[push ? 'pushState' : 'replaceState']({ cwd, filterOutEngines }, '', makeHash(cwd));
    };

    window.onpopstate = ({ state }) => {
      if (ignoreNextState) {
        ignoreNextState = false;
        return;
      }

      filterOutEngines = state.filterOutEngines ?? filterOutEngines;
      navigate(state.cwd ?? cwd);
    };

    vertical_file_graphs.oninput = () => navigate(cwd);

    const get = async url => await (await fetch(url, { cache: 'no-cache' })).json();

    const shortenNames = () => {
      if (vertical_file_graphs.checked) return;

      let nameCache = {};
      const getNameWidth = (el, x) => {
        if (nameCache[x]) return nameCache[x];
        return nameCache[x] = el.children[0].getBoundingClientRect().width;
      };

      const shortenStat = el => {
        const x = el.className.replace('stat-', '');
        const nameLength = getNameWidth(el, x);
        const extraLength = (nameLength / names[x].length) * 6;

        let shortened = false;
        if (nameLength + extraLength > el.getBoundingClientRect().width) {
          el.children[0].textContent = shortNames[x];
          el.children[0].title = names[x];

          shortened = true;
        }

        if ((shortened && names[x] === shortNames[x] && names.length > 2) ||
            (extraLength * 1.3) > el.getBoundingClientRect().width ||
            (['hermes', 'chakra', 'graaljs', 'babel', 'boa'].includes(x) && (nameLength * 1.5) > el.getBoundingClientRect().width)) {
          el.children[0].textContent = '';
          el.title = names[x];
        }
      };

      for (const el of document.querySelectorAll('table .stats > div')) {
        shortenStat(el);
      }

      nameCache = {}; // reset cache for small parent
      /* for (const el of document.querySelectorAll('#proposals .stats > div')) {
        shortenStat(el);
      } */
    };

    let features, editions, cache = {};
    const navigate = async (path) => {
      cwd = path.trim();
      updateHash(true);

      const json = cache[cwd] ?? await get('data/' + (cwd || 'index') + '.json');
      cache[cwd] = json;

      makeTable(path, json);

      if (!init) {
        init = true;

        let overallJson = json;
        if (cwd !== '') overallJson = cache[''] ?? await get('data/index.json');
        cache[''] = overallJson;

        const overallGraph = makeGraph(overallJson, true);
        document.getElementById('before-overall').insertAdjacentElement('afterend', overallGraph);
      }

      setTimeout(shortenNames, 10);

      if (cwd === '') {
        setTimeout(async () => {
          if (!features) features = await get('data/features.json');

          const proposalsEl = document.createElement('div');
          proposalsEl.id = 'proposals';

          for (const feature of Object.values(features).sort((a, b) => b.proposal.stars - a.proposal.stars)) {
            const { proposal, total, engines } = feature;

            const el = document.createElement('div');

            const info = document.createElement('div');
            const name = document.createElement('a');
            name.href = proposal.link;

            name.textContent = proposal.name.replaceAll('`', '').replaceAll('\'', '').replace('The ', '').replace(' Method', '').split(':').pop().split(' and ')[0].replace(' proposal', '').replace(' Proposal', '').replace('.prototype', '').replace(' API', '').replace(' in JavaScript', '').replace(' Attributes', ' Assertions');
            if (name.textContent.toLowerCase().startsWith('proposal-')) name.textContent = name.textContent[9].toUpperCase() + name.textContent.slice(10).replaceAll('-', ' ');

            const stage = document.createElement('span');
            stage.textContent = `Stage ${proposal.stage}`;
            stage.classList = `stage-${proposal.stage}`;

            name.append(stage);

            const desc = document.createElement('div');
            desc.textContent = proposal.description ?? ' ';

            info.append(name, desc);

            el.append(info, makeGraph({ total, engines }, true));
            proposalsEl.append(el);
          }


          
          if (!editions) editions = await get('data/editions.json');
          
          const editionsEl = document.createElement('div');
          editionsEl.id = 'editions';

          for (let i = 5; i <= 14; i++) {
            const { total, engines } = editions[i.toString()];
            let name = i > 6 ? `ES${i+2009}` : `ES${i}`;
            if (i === 14) name = 'ESNext';

            const el = document.createElement('div');
            
            const info = document.createElement('div');
   
            const name = document.createElement('span');
            name.textContent = name;
            
            info.append(name);
            el.append(info, makeGraph({ total, engines }, true));
            editionsEl.append(el);
          }
          
          content.append(editionsEl, proposalsEl);

          setTimeout(shortenNames, 10);
        }, 50);
      } else {
        document.getElementById('proposals')?.remove?.();
      }
    };

    const makeGraph = ({ total, engines }, vertical = false, labelFunc = undefined) => {
      const el = document.createElement('div');
      el.className = 'stats';
      if (vertical) el.classList.add('vertical');

      const keys = Object.keys(engines);
      for (const x of niceEngineOrder) {
        if (!engines[x]) continue;
        let passes = engines[x];

        const stat = document.createElement('div');
        stat.className = 'stat-' + x;

        const percent = (passes / total) * 100;
        stat.style.width = (vertical ? percent : percent / (keys.length - filterOutEngines.length)) + '%';
        stat._percent = percent;

        /* stat.onmouseenter = () => {
          stat.style.cssText = `width: ${percent}% !important`;
        };
        stat.onmouseleave = () => {
          stat.style.width = (vertical ? percent : percent / (keys.length - filterOutEngines.length)) + '%';
        }; */

        const b = document.createElement('b');
        b.textContent = names[x] ?? x;

        const extra = document.createTextNode(labelFunc ? labelFunc(x, passes) : ` ${percent.toFixed(0)}%`);

        stat.append(b, extra);
        el.append(stat);
      }

      return el;
    };

    const makeTable = (file, { total, engines, files }) => {
      tbody.innerHTML = '';
      thead.innerHTML = '';

      const makeHeader = (thContent) => {
        const tr = document.createElement('tr');

        const th = document.createElement('th');
        th.className = file;
        th.colSpan = 2;

        th.append(thContent);
        tr.append(th);
        thead.append(tr);
      };

      const makeRow = (thText, tdContent, onclick, href) => {
        const tr = document.createElement('tr');

        const th = document.createElement('th');
        th.className = file;

        const link = document.createElement('a');
        link.href = href ?? '';

        if (onclick) link.onclick = onclick;

        link.textContent = thText;
        th.append(link);

        const td = document.createElement('td');
        if (tdContent) td.append(tdContent);
          else td.style.borderLeft = 'none';

        tr.append(th, td);
        tbody.append(tr);
      };

      if (file !== '') {
        makeHeader(file);
        makeHeader(makeGraph({ total, engines }, vertical_file_graphs.checked));
        makeRow('..', undefined, () => navigate(cwd.split('/').slice(0, -1).join('/')), makeHash(''));
      }

      for (const file in files) {
        makeRow(file.replace(cwd + '/', ''), makeGraph(files[file], vertical_file_graphs.checked), file.endsWith('.js') ? undefined : () => navigate(file), file.endsWith('.js') ? `https://github.com/tc39/test262/blob/${test262.revision}/test/${file}` : makeHash(file));
      }
    };

    const makeEngines = () => {
      const adjustStatsSizes = factor => {
        const keys = Object.keys(engines);
        const beforeAmount = (keys.length - filterOutEngines.length) - factor;
        const afterAmount = (keys.length - filterOutEngines.length);

        for (const el of document.querySelectorAll('.stats:not(.vertical) > div')) {
          el.style.width = (el._percent / (keys.length - filterOutEngines.length)) + '%';
        }
      };

      const generateEngine = (engine, version = '') => {
        const id = 'filter-engine-' + engine;
        const wrap = document.createElement('div');

        const label = document.createElement('label');
        label.textContent = names[engine];
        label.title = moreInfo[engine] ?? '';
        label.setAttribute('for', id);

        const ver = document.createElement('span');
        ver.textContent = version; // slice revisions

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = id;
        checkbox.checked = !filterOutEngines.includes(engine);

        checkbox.oninput = () => {
          if (filterOutEngines.includes(engine)) {
            filterOutEngines = filterOutEngines.filter(x => x !== engine);
            adjustStatsSizes(1);
          } else {
            filterOutEngines.push(engine);
            adjustStatsSizes(-1);
          }

          document.body.className = filterOutEngines.map(x => `no-stat-` + x).join(' ');
          updateHash();
          makeEngines();
        };

        wrap.append(checkbox, label, ver);
        return wrap;
      };

      const el = document.getElementById('engines');
      el.innerHTML = '';

      let enginesByCategory = {};
      for (const engine of niceEngineOrder) {
        const category = categories[engine] ?? 'engines';

        if (!enginesByCategory[category]) enginesByCategory[category] = [];
        enginesByCategory[category].push(engine);
      }

      let lastCategory, container;
      for (const engine of niceEngineOrder) {
        if (!engines[engine]) continue;

        const category = categories[engine] ?? 'engines';
        if (category !== lastCategory) {
          if (container) el.append(container);
          container = document.createElement('details');
          container.open = true;

          const summary = document.createElement('summary');

          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';

          checkbox.checked = enginesByCategory[category].every(x => !filterOutEngines.includes(x));
          if (!checkbox.checked) checkbox.indeterminate = enginesByCategory[category].some(x => !filterOutEngines.includes(x));

          checkbox.oninput = () => {
            for (const x of enginesByCategory[category]) {
              if (checkbox.checked) {
                filterOutEngines = filterOutEngines.filter(y => y !== x);
                adjustStatsSizes(1);
              } else if (!filterOutEngines.includes(x)) {
                filterOutEngines.push(x);
                adjustStatsSizes(-1);
              }
            };

            document.body.className = filterOutEngines.map(x => `no-stat-` + x).join(' ');
            updateHash();
            makeEngines();
          };

          const header = document.createElement('h3');
          header.textContent = category[0].toUpperCase() + category.slice(1);

          summary.append(checkbox, header);
          container.append(summary);

          lastCategory = category;
        }

        let version = engines[engine];
        if (version.length === 40) version = version.slice(0, 8);
        if (version.length === 46) version = version.slice(0, 14);

        container.append(generateEngine(engine, version.replace('\n', '\n   ')));
      }

      el.append(container);
    };

    let engines;
    (async () => {
      engines = await get('data/engines.json');
      makeEngines();
    })();

    let times;
    (async () => {
      times = await get('data/times.json');

      const prettyAgo = (timestamp, factor = 1) => {
        const intervals = [
          { label: 'year', seconds: 31536000 },
          { label: 'month', seconds: 2592000 },
          { label: 'week', seconds: 604800 },
          { label: 'day', seconds: 86400 },
          { label: 'hour', seconds: 3600 },
          { label: 'minute', seconds: 60 },
          { label: 'second', seconds: 1 }
        ];

        const seconds = Math.floor((Date.now() - timestamp) / 1000);
        const interval = intervals.find(i => i.seconds <= seconds) ?? intervals[intervals.length - 1];
        const count = Math.floor(seconds / interval.seconds);

        const rtf = new Intl.RelativeTimeFormat("en", {
          localeMatcher: 'best fit',
          numeric: 'auto',
          style: 'long'
        });

        return rtf.format(count * factor, interval.label);
      };

      generated_ago.textContent = prettyAgo(new Date(times.generatedAt), -1);

      const worstTime = Math.max(...Object.values(times.timeTaken));
      generated_in.textContent = prettyAgo(new Date(Date.now() - (worstTime * 1000) - (1000 * 60 * 2))).replace('in', 'in about'); // longest engine test time + 2 mins for gen/deploy/stuff

      const timeGraph = makeGraph({
        total: worstTime,
        engines: times.timeTaken
      }, true, (engine, time) => {
        const hours = Math.floor(time / 3600);
        const mins = Math.floor(time % 3600 / 60);
        const secs = time % 3600 % 60;

        return hours > 0 ? ` ${hours}h ${mins}m` : ` ${mins}m`;
      });
      document.getElementById('before-times').insertAdjacentElement('afterend', timeGraph);
    })();

    let test262;
    (async () => {
      test262 = await get('data/test262.json');
      test262_rev.textContent = test262.revision.slice(0, 7);
      test262_rev.href = 'https://github.com/tc39/test262/commit/' + test262.revision;
    })();

    navigate(cwd);
  </script>
</body>
</html>
